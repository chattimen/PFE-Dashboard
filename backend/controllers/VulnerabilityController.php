<?php
/**
 * Contrôleur pour gérer les vulnérabilités
 */
class VulnerabilityController {
    private $vulnerabilityModel;
    
    /**
     * Constructeur
     */
    public function __construct() {
        require_once __DIR__ . '/../models/Database.php';
        require_once __DIR__ . '/../models/VulnerabilityModel.php';
        $this->vulnerabilityModel = new VulnerabilityModel();
    }
    
    /**
     * Récupère toutes les vulnérabilités avec filtrage et pagination
     */
    public function getVulnerabilities($filters = [], $limit = 100, $offset = 0) {
        // Si appelé via l'API, utiliser les paramètres de la requête
        if (empty($filters) && isset($_GET)) {
            // Récupérer les paramètres de la requête
            $filters = [];
            $limit = isset($_GET['limit']) ? intval($_GET['limit']) : 100;
            $offset = isset($_GET['offset']) ? intval($_GET['offset']) : 0;
            
            // Filtres
            if (isset($_GET['tool_name'])) {
                $filters['tool_name'] = $_GET['tool_name'];
            }
            
            if (isset($_GET['severity'])) {
                $filters['severity'] = $_GET['severity'];
            }
            
            if (isset($_GET['status'])) {
                $filters['status'] = $_GET['status'];
            }
            
            if (isset($_GET['scan_id'])) {
                $filters['scan_id'] = intval($_GET['scan_id']);
            }
        }
        
        try {
            $vulnerabilities = $this->vulnerabilityModel->getAllVulnerabilities($filters, $limit, $offset);
            
            // Compter le total pour la pagination
            $totalCount = count($vulnerabilities);
            
            if (isset($_SERVER['REQUEST_METHOD'])) {
                header('Content-Type: application/json');
                echo json_encode([
                    'status' => 'success',
                    'data' => $vulnerabilities,
                    'total' => $totalCount,
                    'limit' => $limit,
                    'offset' => $offset
                ]);
            } else {
                return $vulnerabilities;
            }
        } catch (Exception $e) {
            if (isset($_SERVER['REQUEST_METHOD'])) {
                $this->sendErrorResponse($e->getMessage());
            } else {
                throw $e;
            }
        }
    }
    
    /**
     * Récupère une vulnérabilité par son ID
     */
    public function getVulnerabilityDetails($id) {
        try {
            $vulnerability = $this->vulnerabilityModel->getVulnerabilityById($id);
            
            if (!$vulnerability) {
                if (isset($_SERVER['REQUEST_METHOD'])) {
                    $this->sendErrorResponse("Vulnérabilité non trouvée", 404);
                    return;
                } else {
                    return null;
                }
            }
            
            if (isset($_SERVER['REQUEST_METHOD'])) {
                header('Content-Type: application/json');
                echo json_encode([
                    'status' => 'success',
                    'data' => $vulnerability
                ]);
            } else {
                return $vulnerability;
            }
        } catch (Exception $e) {
            if (isset($_SERVER['REQUEST_METHOD'])) {
                $this->sendErrorResponse($e->getMessage());
            } else {
                throw $e;
            }
        }
    }
    
    /**
     * Ajoute une nouvelle vulnérabilité
     */
    public function addVulnerability($data = null) {
        // Vérifier si la fonction est appelée via API
        if ($data === null) {
            // Vérifier que la requête est en POST
            if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
                $this->sendErrorResponse("Méthode non autorisée", 405);
                return;
            }
            
            // Récupérer les données du corps de la requête
            $data = json_decode(file_get_contents('php://input'), true);
            
            if (!$data) {
                $this->sendErrorResponse("Données invalides");
                return;
            }
        }
        
        // Valider les données requises
        if (empty($data['scan_id']) || empty($data['tool_name']) || empty($data['title']) || empty($data['severity'])) {
            if (isset($_SERVER['REQUEST_METHOD'])) {
                $this->sendErrorResponse("Données manquantes: scan_id, tool_name, title et severity sont requis");
                return;
            } else {
                throw new Exception("Données manquantes: scan_id, tool_name, title et severity sont requis");
            }
        }
        
        try {
            $id = $this->vulnerabilityModel->addVulnerability($data);
            
            if (isset($_SERVER['REQUEST_METHOD'])) {
                header('Content-Type: application/json');
                echo json_encode([
                    'status' => 'success',
                    'message' => 'Vulnérabilité ajoutée avec succès',
                    'id' => $id
                ]);
            } else {
                return $id;
            }
        } catch (Exception $e) {
            if (isset($_SERVER['REQUEST_METHOD'])) {
                $this->sendErrorResponse($e->getMessage());
            } else {
                throw $e;
            }
        }
    }
    
    /**
     * Met à jour une vulnérabilité existante
     */
    public function updateVulnerabilityStatus($id, $status = null) {
        // Si appelé via API
        if ($status === null) {
            // Vérifier que la requête est en PUT ou PATCH
            if ($_SERVER['REQUEST_METHOD'] !== 'PUT' && $_SERVER['REQUEST_METHOD'] !== 'PATCH') {
                $this->sendErrorResponse("Méthode non autorisée", 405);
                return;
            }
            
            // Récupérer les données du corps de la requête
            $data = json_decode(file_get_contents('php://input'), true);
            
            if (!$data || !isset($data['status'])) {
                $this->sendErrorResponse("Données invalides");
                return;
            }
            
            $status = $data['status'];
        }
        
        try {
            $vulnerability = $this->vulnerabilityModel->getVulnerabilityById($id);
            
            if (!$vulnerability) {
                if (isset($_SERVER['REQUEST_METHOD'])) {
                    $this->sendErrorResponse("Vulnérabilité non trouvée", 404);
                    return;
                } else {
                    return false;
                }
            }
            
            $data = ['status' => $status];
            $success = $this->vulnerabilityModel->updateVulnerability($id, $data);
            
            if (isset($_SERVER['REQUEST_METHOD'])) {
                header('Content-Type: application/json');
                echo json_encode([
                    'status' => 'success',
                    'message' => 'Statut de vulnérabilité mis à jour avec succès'
                ]);
            } else {
                return $success;
            }
        } catch (Exception $e) {
            if (isset($_SERVER['REQUEST_METHOD'])) {
                $this->sendErrorResponse($e->getMessage());
            } else {
                throw $e;
            }
        }
    }
    
    /**
     * Récupère les statistiques des vulnérabilités
     */
    public function getVulnerabilityStats($filters = []) {
        // Si appelé via API
        if (empty($filters) && isset($_GET)) {
            $filters = [];
            
            if (isset($_GET['tool_name'])) {
                $filters['tool_name'] = $_GET['tool_name'];
            }
            
            if (isset($_GET['status'])) {
                $filters['status'] = $_GET['status'];
            }
            
            if (isset($_GET['days'])) {
                $filters['days'] = intval($_GET['days']);
            }
        }
        
        try {
            $stats = $this->vulnerabilityModel->getVulnerabilityStats($filters);
            
            if (isset($_SERVER['REQUEST_METHOD'])) {
                header('Content-Type: application/json');
                echo json_encode([
                    'status' => 'success',
                    'data' => $stats
                ]);
            } else {
                return $stats;
            }
        } catch (Exception $e) {
            if (isset($_SERVER['REQUEST_METHOD'])) {
                $this->sendErrorResponse($e->getMessage());
            } else {
                throw $e;
            }
        }
    }
    
    /**
     * Récupère les tendances des vulnérabilités
     */
    public function getVulnerabilityTrends($days = 30) {
        // Si appelé via API
        if (isset($_GET['days'])) {
            $days = intval($_GET['days']);
        }
        
        try {
            $trends = $this->vulnerabilityModel->getVulnerabilityTrends($days);
            
            if (isset($_SERVER['REQUEST_METHOD'])) {
                header('Content-Type: application/json');
                echo json_encode([
                    'status' => 'success',
                    'data' => $trends
                ]);
            } else {
                return $trends;
            }
        } catch (Exception $e) {
            if (isset($_SERVER['REQUEST_METHOD'])) {
                $this->sendErrorResponse($e->getMessage());
            } else {
                throw $e;
            }
        }
    }
    
    /**
     * Envoie une réponse d'erreur au format JSON
     */
    private function sendErrorResponse($message, $statusCode = 400) {
        http_response_code($statusCode);
        header('Content-Type: application/json');
        echo json_encode([
            'status' => 'error',
            'message' => $message
        ]);
    }
    
    /**
     * Alias pour getVulnerabilities (compatibilité)
     */
    public function getAll() {
        return $this->getVulnerabilities();
    }
    
    /**
     * Alias pour getVulnerabilityDetails (compatibilité)
     */
    public function getOne($id) {
        return $this->getVulnerabilityDetails($id);
    }
    
    /**
     * Alias pour getVulnerabilityStats (compatibilité)
     */
    public function getStats() {
        return $this->getVulnerabilityStats();
    }
    
    /**
     * Alias pour getVulnerabilityTrends (compatibilité)
     */
    public function getTrends() {
        return $this->getVulnerabilityTrends();
    }
    
    /**
     * Alias pour addVulnerability (compatibilité)
     */
    public function add() {
        return $this->addVulnerability();
    }
    
    /**
     * Alias pour updateVulnerabilityStatus (compatibilité)
     */
    public function update($id) {
        // Récupérer les données
        $data = json_decode(file_get_contents('php://input'), true);
        if (isset($data['status'])) {
            return $this->updateVulnerabilityStatus($id, $data['status']);
        } else {
            $this->sendErrorResponse("Données invalides: statut manquant");
        }
    }
}